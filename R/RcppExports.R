# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute lag features efficiently
#'
#' @param x Numeric vector to compute lags from
#' @param lags Integer vector of lag positions
#' @return Matrix where each column is a lag
compute_lags_cpp <- function(x, lags) {
    .Call(`_chronofeat_compute_lags_cpp`, x, lags)
}

#' Compute moving averages efficiently
#'
#' @param x Numeric vector
#' @param windows Integer vector of window sizes
#' @return Matrix where each column is an MA with different window
compute_ma_cpp <- function(x, windows) {
    .Call(`_chronofeat_compute_ma_cpp`, x, windows)
}

#' Compute rolling sum efficiently
#'
#' @param x Numeric vector
#' @param windows Integer vector of window sizes
#' @return Matrix where each column is a rolling sum
#' @details Returns NA if the window is incomplete OR if all values in the window are NA.
#'          This matches the R behavior where sum of all-NA with na.rm handling returns NA.
compute_rollsum_cpp <- function(x, windows) {
    .Call(`_chronofeat_compute_rollsum_cpp`, x, windows)
}

#' Compute rolling standard deviation
#'
#' @param x Numeric vector
#' @param windows Integer vector of window sizes
#' @return Matrix where each column is a rolling SD
compute_rollsd_cpp <- function(x, windows) {
    .Call(`_chronofeat_compute_rollsd_cpp`, x, windows)
}

#' Compute rolling min/max
#'
#' @param x Numeric vector
#' @param windows Integer vector of window sizes
#' @param compute_min Logical, if TRUE compute min, else max
#' @return Matrix where each column is rolling min or max
compute_rollminmax_cpp <- function(x, windows, compute_min = TRUE) {
    .Call(`_chronofeat_compute_rollminmax_cpp`, x, windows, compute_min)
}

#' Compute rolling linear trend slope
#'
#' @param x Numeric vector
#' @param windows Integer vector of window sizes
#' @return Matrix where each column is rolling slope
compute_rollslope_cpp <- function(x, windows) {
    .Call(`_chronofeat_compute_rollslope_cpp`, x, windows)
}

#' Create target features for a single time point (used in recursive forecasting)
#'
#' @param y_hist Numeric vector of historical target values
#' @param p Integer, number of lags
#' @param q Integer vector of MA windows
#' @param roll_windows Integer vector of rolling stat windows
#' @param roll_stats Character vector of stats to compute
#' @param trend_windows Integer vector for rolling slopes
#' @return Named list of feature values
make_target_feats_cpp <- function(y_hist, p = NULL, q = NULL, roll_windows = NULL, roll_stats = NULL, trend_windows = NULL) {
    .Call(`_chronofeat_make_target_feats_cpp`, y_hist, p, q, roll_windows, roll_stats, trend_windows)
}

#' Fast recursive forecasting engine (no calendar/xreg version)
#'
#' This is the core forecasting loop optimized for speed.
#' Handles the case with only target-based features (lags, MAs, rolling stats).
#'
#' @param y_hist Numeric vector of historical target values
#' @param model_coef Numeric vector of model coefficients
#' @param has_intercept Logical, if TRUE first coef is intercept
#' @param h Integer, forecast horizon
#' @param p Integer vector of specific lag indices (e.g., c(1, 4, 6, 12))
#' @param q Integer vector of MA windows
#' @param roll_windows Integer vector of rolling stat windows
#' @param roll_stats Character vector of stats to compute
#' @param trend_windows Integer vector for rolling slopes
#' @param trend_degrees Integer vector for polynomial trends
#' @return Numeric vector of forecasts
recursive_forecast_simple_cpp <- function(y_hist, model_coef, has_intercept, h, p = NULL, q = NULL, roll_windows = NULL, roll_stats = NULL, trend_windows = NULL, trend_degrees = NULL) {
    .Call(`_chronofeat_recursive_forecast_simple_cpp`, y_hist, model_coef, has_intercept, h, p, q, roll_windows, roll_stats, trend_windows, trend_degrees)
}

#' Build feature matrix for recursive forecasting (model-agnostic)
#'
#' Builds the complete feature matrix for all h forecast steps.
#' Returns predictions as a vector that gets updated recursively.
#' The caller provides predicted values which are used to update history.
#'
#' @param y_hist Numeric vector of historical target values
#' @param h Integer, forecast horizon
#' @param p Integer vector of specific lag indices (e.g., c(1, 4, 6, 12))
#' @param q Integer vector of MA windows
#' @param roll_windows Integer vector of rolling stat windows
#' @param roll_stats Character vector of stats to compute
#' @param trend_windows Integer vector for rolling slopes
#' @param trend_degrees Integer vector for polynomial trends
#' @param y_future Numeric vector of predicted values (updated recursively)
#' @return Numeric matrix (h x n_features) of features for prediction
build_features_recursive_cpp <- function(y_hist, h, p = NULL, q = NULL, roll_windows = NULL, roll_stats = NULL, trend_windows = NULL, trend_degrees = NULL, y_future = NULL) {
    .Call(`_chronofeat_build_features_recursive_cpp`, y_hist, h, p, q, roll_windows, roll_stats, trend_windows, trend_degrees, y_future)
}

#' Fast recursive forecasting with batched predictions
#'
#' Model-agnostic optimizer - batches predictions to minimize R call overhead.
#' Uses adaptive batching: builds features for multiple steps, predicts in batch,
#' updates history, repeats. Much faster than per-step prediction.
#'
#' @param y_hist Numeric vector of historical target values
#' @param h Integer, forecast horizon
#' @param predict_fn R function that takes a numeric matrix and returns predictions
#' @param p Integer vector of specific lag indices (e.g., c(1, 4, 6, 12))
#' @param q Integer vector of MA windows
#' @param roll_windows Integer vector of rolling stat windows
#' @param roll_stats Character vector of stats to compute
#' @param trend_windows Integer vector for rolling slopes
#' @param trend_degrees Integer vector for polynomial trends
#' @param batch_size Integer, number of steps to predict at once (default: h for full batch)
#' @return Numeric vector of forecasts
forecast_iterative_cpp <- function(y_hist, h, predict_fn, p = NULL, q = NULL, roll_windows = NULL, roll_stats = NULL, trend_windows = NULL, trend_degrees = NULL, batch_size = -1L) {
    .Call(`_chronofeat_forecast_iterative_cpp`, y_hist, h, predict_fn, p, q, roll_windows, roll_stats, trend_windows, trend_degrees, batch_size)
}

#' Fast group-wise recursive forecasting
#'
#' Performs recursive forecasting for multiple groups in parallel.
#'
#' @param y_matrix Numeric matrix where each row is a group's history
#' @param model_coef Numeric vector of model coefficients
#' @param has_intercept Logical, if TRUE first coef is intercept
#' @param h Integer, forecast horizon
#' @param p Integer vector of specific lag indices (e.g., c(1, 4, 6, 12))
#' @param q Integer vector of MA windows
#' @param roll_windows Integer vector of rolling stat windows
#' @param roll_stats Character vector of stats to compute
#' @param trend_windows Integer vector for rolling slopes
#' @param trend_degrees Integer vector for polynomial trends
#' @return Numeric matrix where each row is a group's forecast
recursive_forecast_groups_cpp <- function(y_matrix, model_coef, has_intercept, h, p = NULL, q = NULL, roll_windows = NULL, roll_stats = NULL, trend_windows = NULL, trend_degrees = NULL) {
    .Call(`_chronofeat_recursive_forecast_groups_cpp`, y_matrix, model_coef, has_intercept, h, p, q, roll_windows, roll_stats, trend_windows, trend_degrees)
}

