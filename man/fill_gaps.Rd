% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gap_filling.R
\name{fill_gaps}
\alias{fill_gaps}
\title{Fill Missing Target Values with Configurable Strategies}
\usage{
fill_gaps(
  data,
  target,
  date,
  groups = NULL,
  strategy = "error",
  params = list()
)
}
\arguments{
\item{data}{Data frame with time series data}

\item{target}{Character, name of target column}

\item{date}{Character, name of date column}

\item{groups}{Character vector of group column names (NULL for ungrouped)}

\item{strategy}{Character, gap-filling strategy. One of:
\itemize{
\item \code{"error"} - Fail if any NAs present (default, forces explicit choice)
\item \code{"zero"} - Replace NAs with 0 (appropriate for count data)
\item \code{"locf"} - Last observation carried forward
\item \code{"nocb"} - Next observation carried backward
\item \code{"linear"} - Linear interpolation (Phase 2)
\item \code{"rolling_mean"} - Centered rolling mean (Phase 2)
\item \code{"stl"} - Seasonal decomposition (Phase 3)
\item \code{"borrow"} - Cross-series borrowing for panel data (Phase 3)
\item \code{"custom"} - User-provided function (Phase 4)
}}

\item{params}{List of strategy-specific parameters. Common parameters:
\itemize{
\item \code{max_gap} - Maximum gap length to fill (for locf, nocb)
\item \code{extrapolate} - Allow extrapolation (for linear)
\item \code{window} - Window size (for rolling_mean)
\item \code{period} - Seasonal period (for stl)
\item \code{fn} - User function (for custom)
}}
}
\value{
Data frame with:
\itemize{
\item Original columns
\item Filled target column
\item \code{{target}_is_imputed} - Logical flag indicating imputed values
}
}
\description{
Apply gap-filling strategies to handle missing target values in time series data.
This ensures train/forecast parity by making features deterministic and auditable.
}
\details{
The \code{is_imputed} flag allows downstream models to:
\itemize{
\item Filter out imputed rows if desired
\item Use the flag as a predictor to learn different behavior
\item Weight imputed observations differently
}

Gap-filling respects group boundaries and never fills across groups.
Each group's time series is filled independently.
}
\examples{
\dontrun{
# Retail sales: missing = no sale
sales_filled <- fill_gaps(sales_data, target = "revenue", date = "date",
                          groups = "store", strategy = "zero")

# Sensor data: carry forward up to 3 missing readings
sensor_filled <- fill_gaps(sensor_data, target = "temperature",
                           date = "timestamp", groups = "device",
                           strategy = "locf",
                           params = list(max_gap = 3))

# Check imputation summary
table(sensor_filled$temperature_is_imputed)

# Use filled data in forecasting
ts <- TimeSeries(sensor_filled, date = "timestamp", groups = "device")
m <- fit(temperature ~ p(7) + rollsum(7), data = ts, model = lm)
}
}
