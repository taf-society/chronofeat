% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forecast.R
\name{forecast.tsfeature_fit}
\alias{forecast.tsfeature_fit}
\title{Generate Recursive Multi-Step Forecasts}
\usage{
\method{forecast}{tsfeature_fit}(
  object,
  h = NULL,
  future = NULL,
  xreg_strategy = c("carry", "zeros", "NA", "error"),
  return_index = FALSE,
  use_cpp = TRUE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{object}{A \code{tsfeature_fit} object created by \code{fit()}}

\item{h}{Integer, forecast horizon (number of steps ahead). Required if \code{future} is NULL}

\item{future}{Optional data frame containing future dates and exogenous variables.
Must include date column, group columns, and any raw exogenous variables used in the model}

\item{xreg_strategy}{Strategy for handling missing exogenous variables when \code{future} is NULL:
\itemize{
\item "carry" - Carry forward last observed values
\item "zeros" - Fill with zeros
\item "NA" - Fill with NA
\item "error" - Throw error if exogenous variables needed
}}

\item{return_index}{Logical, if TRUE return forecast steps (1, 2, ..., h) instead of dates}

\item{use_cpp}{Logical, if TRUE use C++ accelerated forecasting when possible (default: TRUE)}

\item{verbose}{Logical, if TRUE print informational messages about which forecasting path is used (default: FALSE)}

\item{...}{Additional arguments (currently unused, for S3 method compatibility)}
}
\value{
Data frame with columns:
\itemize{
\item Group columns (if specified in fit)
\item Date column or step index
\item \code{{target}_forecast} - Point forecasts
}
}
\description{
Produce forecasts from a fitted tsfeature_fit model using recursive prediction.
Each forecast step feeds back into the model as a lag feature for subsequent steps.
}
\details{
The forecast process:
\enumerate{
\item For each group, compute features from history
\item Predict one step ahead
\item Append prediction to history
\item Repeat for h steps
}

If \code{future} is not provided, future dates are generated based on the frequency
stored in the model (from TimeSeries object) or using the median time difference
in the historical data within each group (fallback).
}
\section{Edge Cases During Forecasting}{


\strong{Incomplete Windows for Rolling Statistics:}

During recursive forecasting, when the requested window size exceeds available
history (actual observations + previous predictions), rolling statistics and
moving averages \strong{return NA} to match training behavior.

Example at forecast step 3 with rollsum(7):
\itemize{
\item Available history: 3 predicted values
\item Requested window: 7
\item Result: NA (incomplete window)
}

This ensures consistency between training and forecasting:
\itemize{
\item Training uses \code{slider::slide_dbl(..., .complete = TRUE)} which returns NA for incomplete windows
\item Forecasting mirrors this by returning NA when \code{length(history) < window}
\item Prevents train/test feature distribution mismatch
\item Models see the same NA pattern during training and forecasting
}

The same NA-on-incomplete behavior applies to: rollsd(), rollmin(), rollmax(), rollslope(), and moving averages.

\strong{Unknown Factor Levels:}

If \code{future} contains factor variables with levels not observed during training
(e.g., a new category), those values are silently converted to NA. This can happen with
calendar features if training data doesn't cover all days/months, or with categorical
exogenous variables.

\strong{Trend Features:}

Trend features (trend(1), trend(2), etc.) continue incrementing beyond the training
range. For example, if trained on 100 observations, forecast step 1 will have trend=101.
}

\examples{
\dontrun{
# Fit a model
m <- fit(value ~ p(12) + q(7, 28) + month(),
         data = retail, date = "date", groups = "items", model = lm)

# Generate 24-step ahead forecast
fc <- forecast(m, h = 24)

# Forecast with step index instead of dates
fc <- forecast(m, h = 24, return_index = TRUE)

# Provide future exogenous variables
future_data <- expand.grid(
  date = seq(as.Date("2010-01-01"), by = "month", length.out = 12),
  items = unique(retail$items),
  price = 9.99,
  promotion = 0
)
fc <- forecast(m, future = future_data)
}
}
