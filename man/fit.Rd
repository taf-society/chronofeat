% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit.R
\name{fit}
\alias{fit}
\title{Fit a Time Series Forecasting Model with Formula Interface}
\usage{
fit(formula, data, date = NULL, groups = NULL, model, ...)
}
\arguments{
\item{formula}{A formula specifying the target and features using special syntax:
\itemize{
\item \code{p(k)} - Create k lags of the target (e.g., p(12))
\item \code{q(w1, w2, ...)} - Create moving averages with specified windows (e.g., q(7,28))
\item \code{dow()}, \code{month()}, \code{woy()}, \code{eom()}, \code{dom()} - Calendar features
\item \code{rollsum(w1,w2)}, \code{rollsd(w)}, \code{rollmin(w)}, \code{rollmax(w)} - Rolling statistics
\item \code{rollslope(w)} - Rolling trend slopes
\item \code{lag(varname, k1, k2, ...)} - Lags of exogenous variables
\item \code{ma(varname, w1, w2, ...)} - MAs of exogenous variables
\item Raw column names for direct inclusion
}}

\item{data}{A data frame or TimeSeries object containing the time series data}

\item{date}{Character string naming the date column (Date class required)}

\item{groups}{Character vector naming grouping columns for panel data}

\item{model}{Model specification as a list with \code{fit} and \code{predict} functions, or
a model function (for backward compatibility, e.g., \code{lm}, \code{glm}).
\itemize{
\item \code{fit(y, X, ...)} - Function that fits model with y (response) and X (predictors matrix)
\item \code{predict(object, newdata, ...)} - Function that predicts from fitted model
}}

\item{...}{Additional arguments passed to the model$fit function}
}
\value{
A \code{tsfeature_fit} object containing:
\itemize{
\item \code{model} - The fitted model object
\item \code{data} - Training data with features
\item \code{history_raw} - Raw historical data for forecasting
\item \code{formula} - Expanded formula used for modeling
\item \code{spec} - Feature specifications
\item \code{meta} - Metadata (date, groups)
\item \code{predictors} - Predictor column names
\item \code{schema} - Predictor schema for type consistency
}
}
\description{
Train a forecasting model using a formula-based feature specification.
This function automatically generates time series features (lags, MAs, rolling stats,
calendar features) from the formula and fits the specified model.
}
\details{
The function automatically:
\enumerate{
\item Parses the formula to identify feature specifications
\item Generates all requested features within groups
\item Removes rows with NA values in features (due to lagging/rolling)
\item Fits the model on the feature-engineered data
\item Stores necessary metadata for forecasting
}
}
\section{Edge Cases and Important Behaviors}{


\strong{Data Sorting:}
If using a TimeSeries object, data is automatically sorted by groups and date.
This ensures correct lag and difference calculations. If passing a plain data frame,
ensure it is pre-sorted by groups (if any) and date.

\strong{Minimum Data Requirements:}
\itemize{
\item Lags: If history length < lag number, the lag feature will be NA
\item Moving averages: If history length < window size, returns NA
\item Rolling statistics: Computed on available data (see below)
\item Frequency detection: Requires at least 2 date observations per group
}

\strong{Factor Variables:}
Factor levels observed during training are stored in the model schema. During
forecasting, if new factor levels appear that weren't seen in training, they
will be silently converted to NA. Consider this when using categorical features
like day-of-week or month.
}

\examples{
\dontrun{
# Load retail data
load("data/retail.rda")

# Simple model with 12 lags using linear regression
m1 <- fit(value ~ p(12), data = retail,
          date = "date", groups = "items", model = lm)

# Model with lags, MAs, and calendar features
m2 <- fit(value ~ p(12) + q(7, 28) + month() + dow(),
          data = retail, date = "date", groups = "items", model = lm)

# GLM for count data
m3 <- fit(count ~ p(7) + dow(), data = count_data,
          date = "date", groups = "store",
          model = glm, family = poisson())

# Custom model specification
custom_model <- list(
  fit = function(y, X, ...) {
    # Your custom fitting logic
    train_df <- cbind(data.frame(.response = y), X)
    lm(.response ~ ., data = train_df, ...)
  },
  predict = function(object, newdata, ...) {
    stats::predict(object, newdata = newdata, ...)
  }
)
m4 <- fit(value ~ p(12), data = retail,
          date = "date", groups = "items", model = custom_model)
}
}
