% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/timeseries.R
\name{TimeSeries}
\alias{TimeSeries}
\title{Create a TimeSeries Object with Complete Preprocessing Pipeline}
\usage{
TimeSeries(
  data,
  date,
  groups = NULL,
  frequency = NULL,
  auto_detect = TRUE,
  target = NULL,
  target_na = NULL,
  fill_time = FALSE,
  xreg_na = NULL
)
}
\arguments{
\item{data}{A data frame containing the time series data}

\item{date}{Character string naming the date column. Accepts:
\itemize{
\item \strong{Date}: For daily and longer frequencies (day, week, month, quarter, year)
\item \strong{POSIXct}: Required for sub-daily frequencies (second, minute, halfhour, hour)
}}

\item{groups}{Optional character vector naming grouping columns for panel data.
All preprocessing operations (time grid completion, gap-filling) are performed
independently per group.}

\item{frequency}{Character string or numeric specifying the time frequency:
\itemize{
\item \strong{Sub-daily} (require POSIXct): "second", "minute", "halfhour", "hour"
\item \strong{Daily+} (work with Date or POSIXct): "day", "businessday", "biweekly",
"week", "month", "quarter", "year"
\item \strong{Numeric}: Custom interval in days (e.g., 7 for weekly, 14 for biweekly)
}
If NULL and \code{auto_detect = TRUE}, frequency is inferred from median date/time differences.}

\item{auto_detect}{Logical, if TRUE and frequency is NULL, attempt to detect frequency
from the data. Default: TRUE.}

\item{target}{Character string naming the target column (optional).
Required if \code{target_na} is specified. The target column will be gap-filled
according to the \code{target_na} strategy.}

\item{target_na}{List specifying gap-filling strategy for missing target values.
\itemize{
\item \code{strategy}: Character, one of:
\itemize{
\item \strong{"error"} - Fail if NAs present (forces explicit choice)
\item \strong{"zero"} - Replace NAs with 0 (useful for count data)
\item \strong{"locf"} - Last observation carried forward
\item \strong{"nocb"} - Next observation carried backward
\item \strong{"linear"} - Linear interpolation (time-aware)
\item \strong{"rolling_mean"} - Centered or right-aligned rolling mean
\item \strong{"stl"} - Seasonal-Trend-Loess decomposition (auto-detects period)
\item \strong{"borrow"} - Cross-series borrowing from peer groups
\item \strong{"custom"} - User-provided function
}
\item \code{params}: List of strategy-specific parameters (see Details)
}
Default: NULL (no target gap-filling). Adds \code{{target}_is_imputed} flag column.}

\item{fill_time}{Logical, if TRUE, complete missing dates using \code{tidyr::complete()}.
Uses the \code{frequency} parameter to determine step size. When enabled, adds rows
for missing dates with NA values in all dynamic columns. Respects group boundaries
for panel data. Default: FALSE.}

\item{xreg_na}{Named list specifying gap-filling strategies for exogenous columns.
Each element should be: \code{column_name = list(strategy = "...", params = list(...))}.
\itemize{
\item \strong{Keys}: Column names to fill (must exist in \code{data})
\item \strong{Values}: Lists with \code{strategy} and \code{params} (same as \code{target_na})
}
Example: \code{list(price = list(strategy = "locf"), promo = list(strategy = "zero"))}.
Each column gets its own \code{{column}_is_imputed} flag. Filling is done per-group
if \code{groups} is specified.}
}
\value{
A \code{TimeSeries} object (S3 class) with components:
\itemize{
\item \code{data} - Data frame with completed calendar and filled gaps (if requested)
\item \code{date} - Name of the date column
\item \code{groups} - Names of grouping columns (or NULL)
\item \code{frequency} - Time frequency specification
\item \code{target} - Name of the target column (or NULL)
\item \code{target_na_meta} - Metadata about target gap-filling (or NULL):
\itemize{
\item \code{strategy} - Strategy used
\item \code{params} - Parameters used
\item \code{n_imputed} - Number of values imputed
\item \code{n_total} - Total observations
\item \code{pct_imputed} - Percentage imputed
}
\item \code{xreg_na_meta} - Named list of metadata for each exogenous column (or empty list)
\item \code{time_fill_meta} - Metadata about time grid completion (or NULL):
\itemize{
\item \code{n_added} - Number of rows added
\item \code{by} - Step size used
\item \code{n_total} - Total observations after completion
}
}
}
\description{
This function creates a TimeSeries object that bundles data with frequency information
and provides a comprehensive preprocessing pipeline for time series data. It handles:
\enumerate{
\item Frequency detection and validation
\item Irregular calendar completion (missing dates)
\item Target variable gap-filling
\item Exogenous variable gap-filling
}
}
\details{
All preprocessing is auditable via metadata and \code{is_imputed} flags.
}
\section{Preprocessing Pipeline Order}{

TimeSeries() applies preprocessing in this order:
\enumerate{
\item \strong{Sort data} by groups (if present) and date
\item \strong{Complete time grid} (if \code{fill_time$enabled = TRUE})
\itemize{
\item Per-group for panel data
\item Adds rows for missing dates with NA values
}
\item \strong{Fill target} (if \code{target} and \code{target_na} specified)
\itemize{
\item Uses specified strategy
\item Adds \code{{target}_is_imputed} flag
}
\item \strong{Fill exogenous columns} (if \code{xreg_na} specified)
\itemize{
\item Per-column, per-group filling
\item Adds \code{{column}_is_imputed} flag for each
}
}
}

\section{Gap-Filling Strategy Parameters}{

Common parameters across strategies:
\itemize{
\item \code{max_gap}: Maximum consecutive NAs to fill (default: Inf).
Throws error if gap exceeds this value.
}

Strategy-specific parameters:
\itemize{
\item \strong{linear}: \code{extrapolate = FALSE} - Allow extrapolation beyond observed range
\item \strong{rolling_mean}: \code{window = 7, center = TRUE} - Window size and alignment
\item \strong{stl}: \code{period = NULL, robust = TRUE} - Seasonal period (auto-detected if NULL) and robust fitting
\item \strong{borrow}: \code{method = "median", neighbors = NULL} - Aggregation method and neighbor filtering
\item \strong{custom}: \code{fn = function(y, dates, params) {...}} - User-provided function
}

See \code{?fill_gaps} for detailed documentation of each strategy.
}

\section{Auditability}{

All gap-filling operations add \code{is_imputed} flags:
\itemize{
\item \code{{target}_is_imputed} - Logical vector marking imputed target values
\item \code{{column}_is_imputed} - Logical vector for each exogenous column
}

These flags can be used to:
\itemize{
\item Filter imputed rows: \code{data[!data$sales_is_imputed, ]}
\item Use as model predictor: \code{sales ~ ... + sales_is_imputed}
\item Weight observations: \code{lm(..., weights = ifelse(is_imputed, 0.5, 1))}
}

Metadata is stored in the TimeSeries object for full reproducibility.
}

\examples{
\dontrun{
# ===== Basic Usage =====
# Create TimeSeries with auto-detected frequency
ts <- TimeSeries(retail, date = "date", groups = "store")

# Specify frequency explicitly
ts <- TimeSeries(retail, date = "date", groups = "store", frequency = "day")

# ===== Target Gap-Filling =====
# Fill target with last observation carried forward
ts <- TimeSeries(
  retail,
  date = "date",
  target = "sales",
  target_na = list(strategy = "locf", params = list(max_gap = 7))
)

# Fill target with seasonal decomposition
ts <- TimeSeries(
  retail,
  date = "date",
  groups = "store",
  target = "sales",
  target_na = list(strategy = "stl", params = list(period = 7))
)

# ===== Complete Preprocessing Pipeline =====
# Handle irregular calendar + target gaps + exogenous gaps
ts <- TimeSeries(
  sales_df,
  date = "date",
  groups = c("store", "item"),
  frequency = "day",
  target = "sales",
  target_na = list(strategy = "locf"),
  fill_time = TRUE,  # Complete missing dates using frequency
  xreg_na = list(
    price = list(strategy = "linear"),  # Smooth interpolation
    promo = list(strategy = "zero")     # NA = no promotion
  )
)

# Inspect preprocessing results
print(ts)  # Shows all metadata
summary(ts$data$sales_is_imputed)  # Check how many values imputed

# ===== Using with fit() and forecast() =====
# fit() extracts cleaned data automatically
m <- fit(sales ~ p(7) + price + promo, data = ts, model = lm)

# forecast() uses stored frequency
fc <- forecast(m, h = 14)

# ===== Panel Data Example =====
# Each store gets independent preprocessing
ts <- TimeSeries(
  panel_df,
  date = "date",
  groups = "store",
  frequency = "day",
  target = "sales",
  target_na = list(strategy = "borrow", params = list(method = "median")),
  fill_time = TRUE,  # Uses frequency = "day"
  xreg_na = list(
    price = list(strategy = "locf"),
    temp = list(strategy = "linear")
  )
)

# Metadata shows per-store/column imputation counts
ts$time_fill_meta  # Rows added to complete calendar
ts$target_na_meta  # Target imputation stats
ts$xreg_na_meta    # Exogenous imputation stats per column
}
}
